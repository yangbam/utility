<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>í„°ì¹˜ìŠ¤í¬ë¦° & ë©€í‹°í„°ì¹˜ ì§„ë‹¨ ë„êµ¬</title>
    <meta name="description" content="ìŠ¤ë§ˆíŠ¸í°, íƒœë¸”ë¦¿ì˜ í„°ì¹˜ íŒ¨ë„ ë¶ˆëŸ‰ê³¼ ë©€í‹°í„°ì¹˜ ì„±ëŠ¥ì„ ì§„ë‹¨í•˜ëŠ” ì›¹ ë„êµ¬ì…ë‹ˆë‹¤. í„°ì¹˜ ëŠê¹€(ë°ë“œì¡´), ê³ ìŠ¤íŠ¸ í„°ì¹˜ í˜„ìƒì„ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•˜ì„¸ìš”.">
    <meta name="keywords" content="í„°ì¹˜í…ŒìŠ¤íŠ¸, ë©€í‹°í„°ì¹˜í…ŒìŠ¤íŠ¸, í„°ì¹˜ìŠ¤í¬ë¦°ì§„ë‹¨, ì•¡ì •ë¶ˆëŸ‰í™•ì¸, ê³ ìŠ¤íŠ¸í„°ì¹˜, í„°ì¹˜ëŠê¹€, ì•„ì´í°í„°ì¹˜í…ŒìŠ¤íŠ¸, ê°¤ëŸ­ì‹œí„°ì¹˜í…ŒìŠ¤íŠ¸">
    <meta property="og:title" content="í„°ì¹˜ìŠ¤í¬ë¦° ì •ë°€ ì§„ë‹¨ê¸° ğŸ‘†">
    <meta property="og:description" content="ë‚´ í°ì˜ í„°ì¹˜ëŠ” ì •ìƒì¼ê¹Œ? ë©€í‹°í„°ì¹˜ì™€ ë“œë¡œì‰ í…ŒìŠ¤íŠ¸ë¡œ í™•ì¸í•´ë³´ì„¸ìš”.">
    <meta property="og:type" content="website">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-18HBM95WEK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-18HBM95WEK');
    </script>

    <style>
        :root {
            --bg-color: #000000;
            --text-color: #ffffff;
            --panel-bg: rgba(30, 30, 30, 0.8);
            --accent-color: #00e5ff;
        }

        * {
            box-sizing: border-box;
            touch-action: none; /* Critical: Disable default browser gestures */
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            height: 100dvh; /* Dynamic Viewport Height */
            display: flex;
            flex-direction: column;
        }

        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 1;
        }

        /* HUD Overlay */
        .hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            background-color: var(--panel-bg);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
            pointer-events: none; /* Let touches pass through */
        }

        .touch-count {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
            display: block;
        }

        .touch-status {
            font-size: 0.9rem;
            color: #ccc;
            margin-top: 5px;
        }

        .good-status {
            color: #00e676; /* Green */
            font-weight: bold;
        }

        /* Touch Points Indicators (Created dynamically or drawn on canvas) */
        /* We will draw them on canvas for synchronized updates */

        /* Controls */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            gap: 15px;
        }

        .btn {
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: background 0.2s;
        }

        .btn:active {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* SEO Content (Hidden by default, shown via modal or below fold if not fullscreen app style) 
           For this specific tool, since it's full-screen canvas, we put content in a lower section 
           that might be visible if we allowed scrolling, BUT we disabled scrolling.
           Solution: Use a "Read Info" button to toggle an overlay or put it below the fold 
           and enable scrolling ONLY on the info container. 
        */
        
        .info-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            font-size: 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.7;
        }

        .info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            overflow-y: auto;
            padding: 40px 20px;
            display: none; /* Hidden by default */
            touch-action: auto; /* Enable scroll here */
        }
        
        .info-overlay.active { display: block; }
        .close-info { float: right; font-size: 2rem; cursor: pointer; color: #fff; }

        .seo-content {
            max-width: 1000px;
            margin: 0 auto;
            line-height: 1.6;
            color: #ddd;
        }
        .seo-content h2 { color: var(--accent-color); border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px; }
        .seo-content h3 { color: #ffab40; margin-top: 25px; }

    </style>
</head>
<body>

    <div class="hud">
        <span id="countDisplay" class="touch-count">í„°ì¹˜ ëŒ€ê¸° ì¤‘...</span>
        <div id="statusMsg" class="touch-status">í™”ë©´ì„ í„°ì¹˜í•´ë³´ì„¸ìš”</div>
    </div>

    <button class="info-btn" onclick="toggleInfo()">â„¹ï¸</button>

    <canvas id="drawCanvas"></canvas>

    <div class="controls">
        <button class="btn" onclick="clearCanvas()">ğŸ§¹ í™”ë©´ ì§€ìš°ê¸°</button>
    </div>

    <!-- SEO & Info Overlay -->
    <div id="infoOverlay" class="info-overlay">
        <div class="seo-content">
            <span class="close-info" onclick="toggleInfo()">&times;</span>
            <h1>ìŠ¤ë§ˆíŠ¸í° í„°ì¹˜ìŠ¤í¬ë¦° ìê°€ ì§„ë‹¨</h1>
            
            <p>
                ì´ ë„êµ¬ëŠ” ìŠ¤ë§ˆíŠ¸í°, íƒœë¸”ë¦¿, í˜¹ì€ í„°ì¹˜ ì§€ì› ë…¸íŠ¸ë¶ì˜ íŒ¨ë„ ìƒíƒœë¥¼ ì ê²€í•˜ëŠ” ì›¹ ê¸°ë°˜ ìœ í‹¸ë¦¬í‹°ì…ë‹ˆë‹¤. ë³„ë„ì˜ ì•± ì„¤ì¹˜ ì—†ì´ ë¸Œë¼ìš°ì €(Chrome, Safari, Samsung Internet ë“±)ë§Œìœ¼ë¡œ ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
            </p>

            <h2>1. í„°ì¹˜ ë¶ˆëŸ‰ì˜ ì¢…ë¥˜ì™€ ì§„ë‹¨ë²•</h2>
            <h3>í„°ì¹˜ íŠ / ê³ ìŠ¤íŠ¸ í„°ì¹˜ (Ghost Touch)</h3>
            <p>
                ì†ì„ ëŒ€ì§€ ì•Šì•˜ëŠ”ë°ë„ ìŠ¤ìŠ¤ë¡œ ëˆŒë¦¬ê±°ë‚˜, ë‚´ê°€ ëˆ„ë¥¸ ê³³ê³¼ ë‹¤ë¥¸ ê³³ì´ í„°ì¹˜ë˜ëŠ” í˜„ìƒì…ë‹ˆë‹¤. ì¶©ì „ê¸°ë¥¼ ê½‚ì€ ìƒíƒœì—ì„œ ë°œìƒí•˜ëŠ” ê²½ìš° ì ‘ì§€(Grounding) ë¬¸ì œì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤. ì´ ë„êµ¬ë¥¼ ì¼œë†“ê³  ê°€ë§Œíˆ ì§€ì¼œë³´ë©° ì œë©‹ëŒ€ë¡œ ì ì´ ì°íˆëŠ”ì§€ í™•ì¸í•´ë³´ì„¸ìš”.
            </p>
            
            <h3>í„°ì¹˜ ëŠê¹€ / ë°ë“œì¡´ (Dead Zone)</h3>
            <p>
                í™”ë©´ì˜ íŠ¹ì • ì˜ì—­ì´ í„°ì¹˜ë¥¼ ì¸ì‹í•˜ì§€ ëª»í•˜ëŠ” í˜„ìƒì…ë‹ˆë‹¤. ìº”ë²„ìŠ¤ì— ê·¸ë¬¼ë§ì²˜ëŸ¼ ì„ ì„ ì´˜ì´˜í•˜ê²Œ ê·¸ë ¤ë³´ì„¸ìš”. ì„ ì´ ëšëš ëŠê¸°ê±°ë‚˜ ê·¸ë ¤ì§€ì§€ ì•ŠëŠ” êµ¬ê°„ì´ ìˆë‹¤ë©´ í•˜ë“œì›¨ì–´ ê²°í•¨ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì£¼ë¡œ ë‚™í•˜ ì¶©ê²©ìœ¼ë¡œ ì¸í•œ ë””ì§€íƒ€ì´ì € ì†ìƒì´ ì›ì¸ì…ë‹ˆë‹¤.
            </p>

            <h2>2. ë©€í‹°í„°ì¹˜ ì„±ëŠ¥ í™•ì¸</h2>
            <p>
                ëŒ€ë¶€ë¶„ì˜ ìµœì‹  ìŠ¤ë§ˆíŠ¸í°ì€ 10ê°œê¹Œì§€ì˜ ë©€í‹°í„°ì¹˜ë¥¼ ì§€ì›í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì¼ë¶€ ì €ê°€í˜• ê¸°ê¸°ë‚˜ ì•¡ì • êµì²´ ìˆ˜ë¦¬ë¥¼ ë°›ì€ ê¸°ê¸°(ê°€í’ˆ ì•¡ì • ì‚¬ìš© ì‹œ)ëŠ” 2~5ê°œê¹Œì§€ë§Œ ì¸ì‹ë˜ê±°ë‚˜, ì—¬ëŸ¬ ê°œë¥¼ ëˆ„ë¥´ë©´ ì ì´ í•©ì³ì§€ëŠ” í˜„ìƒì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—´ ì†ê°€ë½ì„ ëª¨ë‘ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”. 5ê°œ ì´ìƒ ë™ì‹œì— ì •ìƒ ì¸ì‹ë˜ë©´ "ë©€í‹°í„°ì¹˜ ì •ìƒ(Good)" ë©”ì‹œì§€ê°€ ëœ¹ë‹ˆë‹¤.
            </p>

            <h2>3. ì•¡ì • ë³´í˜¸ í•„ë¦„ê³¼ í„°ì¹˜ ê°ë„</h2>
            <p>
                ë‘êº¼ìš´ ê°•í™”ìœ ë¦¬ í•„ë¦„ì€ í„°ì¹˜ ë¯¼ê°ë„ë¥¼ ë–¨ì–´ëœ¨ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°¤ëŸ­ì‹œ íœ´ëŒ€í°ì˜ ê²½ìš° [ì„¤ì •] > [ë””ìŠ¤í”Œë ˆì´] > [í„°ì¹˜ ë¯¼ê°ë„] ì˜µì…˜ì„ ì¼œë©´ ê°œì„ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§Œì•½ í•„ë¦„ ë¶€ì°© í›„ í„°ì¹˜ ì˜¤ë¥˜ê°€ ì¦ë‹¤ë©´ í•„ë¦„ì„ ì œê±°í•˜ê³  ë‹¤ì‹œ í…ŒìŠ¤íŠ¸í•´ë³´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
            </p>

            <h2>4. ì•„ì´í° vs ê°¤ëŸ­ì‹œ í„°ì¹˜ ìƒ˜í”Œë§ ë ˆì´íŠ¸</h2>
            <p>
                í™”ë©´ ì£¼ì‚¬ìœ¨(120Hz)ê³¼ëŠ” ë³„ê°œë¡œ, í„°ì¹˜ ì…ë ¥ì„ ê°ì§€í•˜ëŠ” ì†ë„ë¥¼ 'í„°ì¹˜ ìƒ˜í”Œë§ ë ˆì´íŠ¸'ë¼ê³  í•©ë‹ˆë‹¤. ë³´í†µ ê²Œì´ë° í°ì€ 240Hz~480Hzê¹Œì§€ ì§€ì›í•˜ì—¬ ë¯¸ì„¸í•œ ì†ê°€ë½ ì›€ì§ì„ì„ ë” ë¹ ë¥´ê³  ì •í™•í•˜ê²Œ ì¶”ì í•©ë‹ˆë‹¤. ì´ ë„êµ¬ì—ì„œ ë§¤ìš° ë¹ ë¥´ê²Œ ì›ì„ ê·¸ë ¸ì„ ë•Œ ì„ ì´ ê°ì§€ì§€ ì•Šê³  ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ìœ¼ë¡œ ë‚˜íƒ€ë‚ ìˆ˜ë¡ ìƒ˜í”Œë§ ë ˆì´íŠ¸ê°€ ì¢‹ì€ ê¸°ê¸°ì…ë‹ˆë‹¤.
            </p>
            <br><br>
            <button class="btn" style="width:100%;" onclick="toggleInfo()">í…ŒìŠ¤íŠ¸ë¡œ ëŒì•„ê°€ê¸°</button>
            <br><br><br>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const countDisplay = document.getElementById('countDisplay');
        const statusMsg = document.getElementById('statusMsg');

        // Color palette for different fingers (Touch IDs)
        // Using distinct neon colors
        const colors = [
            '#FF1744', '#00E676', '#2979FF', '#FFEA00', '#D500F9',
            '#FF9100', '#00B0FF', '#76FF03', '#F50057', '#651FFF'
        ];

        // Store active touches
        let activeTouches = {}; // key: identifier, value: {x, y, color}

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Redraw persistent paths if we were storing them (optional, but clearing is safer for simplicity)
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function getTouchColor(id) {
            // Simple hash or modulo to pick consistent color for ID
            // Identifiers can be large integers on some devices
            // We'll use a persistent random assignment or simple index for sequential touches?
            // Let's rely on modulo of ID, though IDs might not be sequential.
            // Better: Assign based on how many touches are active or random but cached?
            // Actually, standard is usually sequential 0..N in Touch List? No, identifiers are unique.
            // Let's just use modulo.
            return colors[Math.abs(id) % colors.length];
        }

        // --- Touch Event Handlers ---
        
        function handleStart(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                activeTouches[touch.identifier] = {
                    x: touch.clientX,
                    y: touch.clientY,
                    color: getTouchColor(touch.identifier)
                };
                
                // Draw initial dot
                ctx.beginPath();
                ctx.arc(touch.clientX, touch.clientY, 10, 0, 2 * Math.PI);
                ctx.fillStyle = activeTouches[touch.identifier].color;
                ctx.fill();
            }
            updateHUD(e.touches.length);
        }

        function handleMove(e) {
            e.preventDefault();
            const touches = e.changedTouches;

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const prev = activeTouches[touch.identifier];
                
                if (prev) {
                    // Draw Line
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(touch.clientX, touch.clientY);
                    ctx.strokeStyle = prev.color;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();

                    // Update pos
                    prev.x = touch.clientX;
                    prev.y = touch.clientY;
                }
            }
            
            // Re-render cursors on top? 
            // Canvas logic: If we just draw lines, the old cursors are overdrawn. 
            // For a paint app, just lines are fine. 
            // For diagnostics, seeing the CURRENT point is helpful.
            // We can rely on drawing the "current" indicator in an animation loop or 
            // just draw a circle at the end of every move.
            // Let's draw a small indicator at tip.
            
            // To do this cleanly without smearing, we usually need two layers:
            // 1. Persistent Drawing Layer (Canvas)
            // 2. Transient Cursor Layer (DOM or 2nd Canvas)
            // For simplicity in single file, we will just draw circles on top of the line. 
            // It leaves a "trail" of circles, which is actually fine/good for density checking.
        }

        function handleEnd(e) {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                delete activeTouches[touches[i].identifier];
            }
            updateHUD(e.touches.length);
        }

        canvas.addEventListener('touchstart', handleStart, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
        
        // Mouse Fallback for testing on PC
        let isMouseDown = false;
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            activeTouches['mouse'] = { x: e.clientX, y: e.clientY, color: colors[0] };
            ctx.beginPath();
            ctx.arc(e.clientX, e.clientY, 10, 0, 2*Math.PI);
            ctx.fillStyle = colors[0];
            ctx.fill();
            updateHUD(1);
        });
        canvas.addEventListener('mousemove', (e) => {
            if(!isMouseDown) return;
            const prev = activeTouches['mouse'];
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(e.clientX, e.clientY);
            ctx.strokeStyle = prev.color;
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.stroke();
            prev.x = e.clientX;
            prev.y = e.clientY;
        });
        canvas.addEventListener('mouseup', () => { isMouseDown = false; delete activeTouches['mouse']; updateHUD(0); });
        canvas.addEventListener('mouseleave', () => { isMouseDown = false; delete activeTouches['mouse']; updateHUD(0); });


        function updateHUD(count) {
            countDisplay.innerText = `ì¸ì‹ëœ ì†ê°€ë½: ${count}ê°œ`;
            
            if (count === 0) {
                statusMsg.innerText = "í™”ë©´ì„ í„°ì¹˜í•´ë³´ì„¸ìš”";
                statusMsg.classList.remove('good-status');
            } else if (count >= 5) {
                statusMsg.innerText = "âœ¨ ë©€í‹°í„°ì¹˜ ì •ìƒ (Excellent!)";
                statusMsg.classList.add('good-status');
            } else {
                statusMsg.innerText = "í„°ì¹˜ ì¶”ì  ì¤‘...";
                statusMsg.classList.remove('good-status');
            }
            
            // Visualization of coordinates? (Optional per requirement 2: "ID and Coordinates")
            // Since we use Canvas for drawing, showing text near finger is hard without clearing/redrawing whole frame.
            // Requirement says "Draw circles and show ID/Coords NEXT to them". 
            // If strictly following this, we need an Animation Frame loop to clear/redraw cursors over independent background layer.
            // BUT user also asked for "Trajectory Drawing" (Line). 
            // If we clear frame, we lose the line.
            // Solution: Use DOM elements for the live cursors to overlay text/circle, use Canvas for the permanent line trail.
            updateCursorOverlays();
        }

        // --- DOM Cursor Overlay System ---
        // We need an overlay container
        const cursorContainer = document.createElement('div');
        cursorContainer.style.position = 'absolute';
        cursorContainer.style.top = '0';
        cursorContainer.style.left = '0';
        cursorContainer.style.width = '100%';
        cursorContainer.style.height = '100%';
        cursorContainer.style.pointerEvents = 'none'; // Click-through
        cursorContainer.style.zIndex = '5';
        document.body.appendChild(cursorContainer);

        function updateCursorOverlays() {
            // This function is tricky to sync perfectly with events without lag,
            // but we can update DOM positions in the `handleMove` directly or use requestAnimationFrame.
            // Let's use `activeTouches` data.
            // We need to sync the DOM elements with activeTouches.
        }

        // Let's enhance handleMove to update DOM cursors.
        // We will create specific DOM elements for each touch.
        // Rewriting handler logic slightly to support DOM cursors.
        
        function getOrCreateCursor(id, color) {
            let el = document.getElementById('cursor-' + id);
            if (!el) {
                el = document.createElement('div');
                el.id = 'cursor-' + id;
                el.style.position = 'absolute';
                el.style.width = '60px'; // larger touch target visual
                el.style.height = '60px';
                el.style.border = `3px solid ${color}`;
                el.style.borderRadius = '50%';
                el.style.transform = 'translate(-50%, -50%)';
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.justifyContent = 'center';
                el.style.color = 'white';
                el.style.fontWeight = 'bold';
                el.style.textShadow = '0 0 4px black';
                el.style.pointerEvents = 'none';
                
                const info = document.createElement('span');
                info.style.position = 'absolute';
                info.style.top = '-25px';
                info.style.fontSize = '12px';
                info.style.whiteSpace = 'nowrap';
                info.className = 'cursor-info';
                
                el.appendChild(info);
                cursorContainer.appendChild(el);
            }
            return el;
        }

        function removeCursor(id) {
            const el = document.getElementById('cursor-' + id);
            if (el) el.remove();
        }

        // Hooking DOM updates into events
        // We'll wrap the logic:
        
        const originalStart = handleStart; // backup
        canvas.removeEventListener('touchstart', handleStart, {passive:false});
        // We already assigned listeners, let's just override or add inside.
        
        // Easier: Just rewrite the handlers logic in one place since I am authoring the file now.
        // Implementing proper DOM sync inside handlers now.
        
    </script>
    
    <!-- Reloading script logic correctly for DOM + Canvas hybrid -->
    <script>
        // Clean slate for Logic
        const cursors = {}; // DOM elements map

        function updateTouchDOM(id, x, y, color) {
            let el = cursors[id];
            if (!el) {
                el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.border = `2px solid ${color}`; // Ring
                el.style.backgroundColor = 'rgba(255,255,255,0.2)';
                el.style.width = '50px';
                el.style.height = '50px';
                el.style.borderRadius = '50%';
                el.style.transform = 'translate(-50%, -50%)';
                
                // Label
                let label = document.createElement('div');
                label.className = 'info-label';
                label.style.position = 'absolute';
                label.style.top = '-20px';
                label.style.left = '50%';
                label.style.transform = 'translateX(-50%)';
                label.style.color = '#fff';
                label.style.fontSize = '12px';
                label.style.textShadow = '0 1px 2px #000';
                label.style.whiteSpace = 'nowrap';
                el.appendChild(label);
                
                cursorContainer.appendChild(el);
                cursors[id] = el;
            }
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.querySelector('.info-label').innerText = `${id} (${Math.round(x)},${Math.round(y)})`;
        }
        
        function removeTouchDOM(id) {
            if (cursors[id]) {
                cursors[id].remove();
                delete cursors[id];
            }
        }

        // Re-bind Events knowing we have DOM logic
        canvas.ontouchstart = (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            for(let i=0; i<touches.length; i++) {
                const t = touches[i];
                const c = getTouchColor(t.identifier);
                activeTouches[t.identifier] = {x: t.clientX, y: t.clientY, color: c};
                
                // Canvas Dot
                ctx.beginPath();
                ctx.arc(t.clientX, t.clientY, 8, 0, Math.PI*2); // Start dot
                ctx.fillStyle = c;
                ctx.fill();

                // DOM Cursor
                updateTouchDOM(t.identifier, t.clientX, t.clientY, c);
            }
            updateHUD(e.touches.length);
        };

        canvas.ontouchmove = (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            for(let i=0; i<touches.length; i++) {
                const t = touches[i];
                const prev = activeTouches[t.identifier];
                if(prev) {
                    // Line
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(t.clientX, t.clientY);
                    ctx.strokeStyle = prev.color;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    prev.x = t.clientX;
                    prev.y = t.clientY;

                    // DOM Overlay Update
                    updateTouchDOM(t.identifier, t.clientX, t.clientY, prev.color);
                }
            }
        };

        canvas.ontouchend = (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            for(let i=0; i<touches.length; i++) {
                const t = touches[i];
                delete activeTouches[t.identifier];
                removeTouchDOM(t.identifier);
            }
            updateHUD(e.touches.length);
        };
        
        canvas.ontouchcancel = canvas.ontouchend;

        // Mouse (Mock) overrides
        // ... (Already implemented above, just ensure it calls updateTouchDOM too if we want mouse cursor visual)
        // For production touch tool, mouse is less critical but good for debugging.
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function toggleInfo() {
            const el = document.getElementById('infoOverlay');
            el.classList.toggle('active');
        }
    </script>
</body>
</html>
